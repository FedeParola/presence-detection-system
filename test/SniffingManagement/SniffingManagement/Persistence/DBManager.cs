using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Npgsql;
using SniffingManagement.Trilateration;

namespace SniffingManagement.Persistence
{
    /*TODO: manage exceptions?
     Test all the queries!*/
    class DBManager
    {
        private NpgsqlConnection conn;
        private NumberFormatInfo nfi = new NumberFormatInfo();
        
        public DBManager(String host, String user, String pass, String database)
        {
            /*Creates the db 'database' if it doesn't exist*/
            //CreateDB(host, database);

            conn = new NpgsqlConnection("Host = " + host + ";" + 
                                        "Username = " + user + ";" +
                                        "Password = " + pass + ";" +
                                        "Database = " + database);

            /*Creates the table 'Record' if it doesn't exist 
             (the db and the user to which the table belongs probably are the same of the connection  
             used to execute the command, so I don't need to specify them in the creation of the table)*/
            CreateRecordsTable();

            nfi.NumberDecimalSeparator = ".";
        }

        private void CreateDB(String host, String dbName){
            using (var adminConn = new NpgsqlConnection("Host = " + host + "; Username = postgres; Password = admin;"))
            {
                using (var cmd = new NpgsqlCommand())
                {
                    /*This syntax doesn't exist! And do we really want to create the db via the application?*/
                    cmd.Connection = adminConn;
                    cmd.CommandText =
                        "CREATE DATABASE IF NOT EXISTS \"" + dbName + "\" " +
                        "WITH OWNER = user " +
                        "ENCODING = 'UTF8' " +
                        "CONNECTION LIMIT = -1;";
                    adminConn.Open();
                    cmd.ExecuteNonQuery();
                    adminConn.Close();
                }             
            }
        }

        private void CreateRecordsTable(){
            using (var cmd = new NpgsqlCommand())
            {
                cmd.Connection = conn;
                cmd.CommandText =
                    "CREATE TABLE IF NOT EXISTS \"Record\"(" +
                    "\"Id\" bigserial PRIMARY KEY," +
                    "\"Hash\" character(32) NOT NULL," +
                    "\"MAC\" character(17) NOT NULL," +
                    "\"SSID\" character varying(256) NOT NULL," +
                    "\"Timestamp\" bigint NOT NULL," +
                    "\"X\" real NOT NULL," +
                    "\"Y\" real NOT NULL)";
                conn.Open();
                cmd.ExecuteNonQuery();
                conn.Close();
            }
        }

        /*TODO: we should call this method somewhere in the sniffingManager*/
        public void CloseConn(){
            if (conn != null)
                ((IDisposable)conn).Dispose();
        }

        /*The use of parameters should prevent from (non intentional) SQL injection because of the SSID*/
        public int InsertRecords(List<Packet> packets){
            int returnValue;
            int counter = 0;

            using (var cmd = new NpgsqlCommand())
            {
                cmd.Connection = conn;
                cmd.CommandText =
                    "INSERT INTO \"Record\" (\"Hash\", \"MAC\", \"SSID\", \"Timestamp\", \"X\", \"Y\") VALUES ";
                /*The drawback of the use of parameters this way is that we could end with a lot of parameters
                 (is that the case or usually we end up with not so many packets since they represent the packets
                 generated by smartphones in just one room (more or less) and also have to be collected by every esp?)
                 The alternative could be to use just one parameter and have one insert for each packet*/
                foreach (Packet p in packets){
                    cmd.CommandText += String.Format("(" +
                                        "'" + p.Hash + "', " +
                                        "'" + p.MacAddr + "', " +
                                        "@ssid{0}," +
                                        p.Timestamp + ", " +
                                        p.Position.X.ToString(nfi) + ", " +
                                        p.Position.Y.ToString(nfi) +
                                        "), ", counter);
                    cmd.Parameters.AddWithValue("@ssid" + counter, p.Ssid);
                    counter++;
                }
                cmd.CommandText = cmd.CommandText.Remove(cmd.CommandText.Length - 2, 2) + ";";

                conn.Open();
                returnValue = cmd.ExecuteNonQuery();
                conn.Close();
            }

            /*number of rows affected... consider returning void*/
            return returnValue;
        }

        /*'timeInterval' represents the length (in milliseconds) of the previous period of time during which
         we have to count the distinct detected devices*/
        public int CountDetectedDevices(long timeInterval){
            int result;
            long startingTimeInstant = new DateTimeOffset(DateTime.Now).ToUnixTimeMilliseconds() - timeInterval;

            using (var cmd = new NpgsqlCommand())
            {
                /*rilevati continuativamente?*/
                cmd.Connection = conn;
                cmd.CommandText = 
                    "SELECT COUNT (DISTINCT \"MAC\") " +
                    "FROM \"Record\" WHERE \"Timestamp\" >= " + startingTimeInstant + ";";
                conn.Open();
                using (var reader = cmd.ExecuteReader())
                {
                    reader.Read();
                    result = reader.GetInt32(0);
                }
                conn.Close();
            }

            return result;
        }

        /*'timeInterval' represents the length (in milliseconds) of the previous period of time considered for the statistics*/
        public Dictionary<String, Point> EstimateDevicesPosition(long timeInterval){
            Dictionary <String, Point> DevicesPositions = new Dictionary<String, Point>();
            long startingTimeInstant = new DateTimeOffset(DateTime.Now).ToUnixTimeMilliseconds() - timeInterval;

            using (var cmd = new NpgsqlCommand())
            {
                cmd.Connection = conn;
                cmd.CommandText =
                "SELECT \"MAC\", \"X\", \"Y\" FROM(" +
                "   SELECT \"MAC\", \"X\", \"Y\", ROW_NUMBER () OVER(PARTITION BY \"MAC\"" +
                                                                    "ORDER BY \"Timestamp\" DESC)" +
                "   FROM \"Record\"" +
                "   WHERE \"Timestamp\" >= " + startingTimeInstant +
                ") \"Devices\"" +
                "WHERE ROW_NUMBER = 1;";
                conn.Open();
                using (var reader = cmd.ExecuteReader())
                {
                    while(reader.Read())
                    {
                        Point p = new Point(reader.GetDouble(1), reader.GetDouble(2));
                        DevicesPositions.Add(reader.GetString(0), p);
                    }
                }
                conn.Close();
            }

            return DevicesPositions;
        }

        /*OPTIONAL EXTENSIONS*/

        /*The 'minThreshold' represents the minimum number of times a device must be detected to be considered 'talkative' */
        public List<String> GetTalkativeDevices(long startInstant, long stopInstant, int minThreshold){
            List<String> macAddresses = new List<String>();

            using (var cmd = new NpgsqlCommand())
            {
                cmd.Connection = conn;
                cmd.CommandText =
                    "SELECT \"MAC\", \"NoOfAppearances\" FROM (" +
                    "   SELECT \"MAC\", COUNT(*) AS \"NoOfAppearances\" " +
                    "   FROM \"Record\"" +
                    "   WHERE \"Timestamp\" >=" + startInstant + "AND" +
                             "\"Timestamp\" <" + stopInstant +
                    "   GROUP BY \"MAC\" " +
                    "   ) \"Macs\"" +
                    "WHERE \"NoOfAppearances\" >= " + minThreshold + ";";
                conn.Open();
                using (var reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        macAddresses.Add(reader.GetString(0));
                    }
                }
                conn.Close();
            }           

            return macAddresses;

            /*...e riportante IN QUALI INTERVALLI TALI DISPOSITIVI SONO STATI RILEVATI! */
        }

         /*Ha senso considerare posizioni relative allo stesso mac
         temporalmente molto vicine?*/
        public Dictionary<String, List<Location>> GetDevicesMovements(long startInstant, long stopInstant){
            Dictionary <String, List<Location>> positionsSequence = new Dictionary<String, List<Location>>();

            using (var cmd = new NpgsqlCommand())
            {
                cmd.Connection = conn;
                cmd.CommandText =
                    "SELECT \"MAC\", \"Timestamp\", \"X\", \"Y\"" +
                    "FROM \"Record\"" +
                    "WHERE \"Timestamp\" >= " + startInstant + "AND" +
                    "      \"Timestamp\" < " + stopInstant + "" +
                    "ORDER BY \"Timestamp\" ASC;";
                conn.Open();
                using (var reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        if (!positionsSequence.ContainsKey(reader.GetString(0)))
                        {
                            positionsSequence.Add(reader.GetString(0), new List<Location>());
                        }

                        Point p = new Point(reader.GetDouble(2), reader.GetDouble(3));
                        Location l = new Location(p, reader.GetInt64(1));
                        positionsSequence[reader.GetString(0)].Add(l);
                    }
                }
                conn.Close();
            }

            return positionsSequence;
        }
    }
}
